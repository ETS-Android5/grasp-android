* 19.04.2022

Na razie moze tego az tak nie cyzelujmy. Szanse,
zeby miec wiele obiektow '(), sa raczej marne, wiec
te droge takze omijamy.


Na razie z istotnych rzeczy
- chcemy uwspolnic ostatni indeks spacji
  z pierwszym indeksem symbolu
- chcemy uwspolnic ostatni indeks symbolu
  z pierwszym indeksem spacji
- zaimplementowac dodawanie symboli
- zaimplementowac dodawanie list
- spacje i nowe linie wewnatrz symboli
  rozbijaja symbole na dwie czesci
- strzalki w gore i w dol
- strzalki w lewo i w prawo powinny
  dzialac przestrzennie


No, ale pobieranie nullowych spacji
tez bedzie trzeba poprawic

* 18.04.2022

rekapitulujac, chcemy, zeby
(cursor-climb-front '(1) '(())) ===> ([ 1))

Wydaje sie jednak, ze ta zmiana napotka na pewne
problemy, z ktorymi nie wiemy, jak sobie poradzic.

Mowiac konkretnie, chodzi o reprezentacje.
Gdybysmy mogli miec dowolnie wiele obiektow '(),
ktore bylyby sobie "eq", sprawa radykalnie by sie
uproscila, bo nie potrzebowalibysmy wlasciwosci
(null-head-space) i (null-tail-space), zas obiekt
'() sam by sie mogl zajmowac swoimi indeksami.

Alternatywa jest taka, zeby przemodelowac interfejs
part-at tak, zeby zamiast indeksu bral kursor i poziom.

* 15.04.2022

Trzeba poprawic iterowanie po listach pustych,
tak zeby miec cos w rodzaju:

( ( ) )
^^^^^^^ 
[01112]
vv[0]vv
  vvv


* 14.04.2022

chyba w pierwszej kolejnosci trzeba sie zajac
tymi pozycjami kursora (tzn. markowac kursor
w trakcie renderowania pustych list oraz
poprawic nawigowanie kursorem na pustych
listach)

jest tez taki pomysl - poniewaz na razie
edycja zachowuje sie troche dziwacznie
- zeby zmienic sposob iterowania kursora,
tzn. chcielibysmy, zeby koniec symbolu
i poczatek spacji byly miedzy soba
nierozroznialne, i zeby wcisniecie spacji
na koncu symbola powodowalo przyrost spacji,
zas wcisniecie klawisza "symbolicznego"
powodowalo dopisanie fragmentu 


* 13.04.2022

upierdliwe wydaja sie nastepujace bugi:
1. cos jest nie tak z mierzeniem wysokosci 
w sytuacji kiedy mamy wiecej niz jedna linie
- ok, zrobione

2. umieszczanie kursora w spacjach (zwlaszcza
wielo-liniowych) wydaje sie skefione
(no i pytanie o obsluge listy pustej)

3. backspace za pierwszym elementem dziala
wadliwie (kasuje drugi element), a delete
przed pierwszym elementem w ogole nie dziala
- OK, to juz dziala!

(ale jeszcze backspace nie dziala w sposob
ciagly)

4. cos jest nie tak z pozycjami kursorow
po operacjach edycji i trzeba to przemyslec
i poprawic

ponadto brakuje nastepujacych ficzerow:

5. mozliwosc dodawania nowych symboli

6. obsluga spacji i entera w symbolu

7. obsluga strzalek do gory i w dol

8. obsluga myszy

* 12.04.2022

to teraz moze obsluzymy klawisze #\space i #\newline
w Spacji

ok, to juz mniej wiecej dziala.

* 11.04.2022

no dobra, rozwazmy, w jaki sposob iterowac po spacjach.
Jak mamy (0), to dopuszczamy tylko jeden indeks, 0
Jak mamy (1), to dopuszczamy dwa indeksy: 0 i 1
Jak mamy (0 0) to dopuszczamy dwa indeksy: 0 i 1

itd.

teraz rozwazmy jeszcze scenariusze kasowania:

( define ... )
 ^

jak wcisniemy backspace, to nic sie dziac nie powinno,
ale jak wcisniemy delete, to powinnismy skasowac
nastepne wyrazenie

a moze jakos inaczej?


* 08.04.2022

iterowanie po spacjach wprawdzie dziala, ale mocno
jako tako. trzeba sie teraz zajac jeszcze taka kwestia:
co sie ma dziac, gdy wciskamy #\backspace albo #\delete
na spacji?

* 07.04.2022

tym, co idealnie chcielibysmy zrobic w najblizszym
czasie, jest dodawanie nowych symboli i wyrazen,
ale konieczna jeszcze bedzie indeksacja spacji

* 06.04.2022

w wiekszosci spacje udalo sie zrefaktorowac.
nie dziala jeszcze obsluga dotykania, ale
to juz wczesniej nie za bardzo dzialalo i
bylo do poprawki, wiec nie ma czego zalowac.

* 05.04.2022

to co dzisiaj robimy?
moze te spacje?
to tutaj idea jest taka, ze mamy obiekt
(Space fragments: list)
gdzie lista zawiera albo liczby (oznaczajace
ilosc spacji przed kolejnym obiektem), albo
"pudelka" (oznaczajace wykomentowane wyrazenia).

Jezeli mamy nastepujace po sobie dwie liczby,
to interpretujemy je tak, ze pomiedzy nimi jest
nowa linia

* 04.04.2022

na pewno trzeba tez zaimplementowac laczenie
spacji w usuwanych symbolach

no, to juz jest jako tako zrobione, ale okazuje
sie, ze sa bledy przy wyliczaniu rozmiarow wyrazen

byc moze tez wlasnie teraz jest najlepszy moment
na zaimplementowanie spacji-jako-typu Indexable,
oraz na przemyslenia zwiazane z tym, jak realizowac
dodawanie i usuwanie elementow.

Mamy bowiem dwie strategie: albo robimy jawna
rekurencje, tak jak w przypadku take-cell-at!
i put-cell-into!, albo opieramy sie na niejawnej
rekurencji tak jak zrobilismy teraz ("send-char!").

Zaleta tej drugiej strategii jest rozszerzalnosc,
natomiast wada jest to, ze implementacja musi
dodatkowo pamietac o zarejestrowaniu operacji,
zeby mozna je bylo odwracac

Z kolei wydaje sie, ze problemem z ta pierwsza
opcja jest brak rozszerzalnosci, choc pewnie to by
sie dalo jakos rozwiazac

W kazdym razie na te chwile chyba nie bedziemy
nic robic z tym 'problemem', i zajmiemy sie nim
dopiero wtedy, kiedy bedziemy robic rozszerzenia.

Czyli do zrobienia na teraz mamy:
- poprawke bledu z wymiarowaniem nawiasow?
- poprawke bledu z iterowaniem po pustych listach
- dodawanie symboli i list


* 02.04.2022

skoro zaimplementowalismy usuwanie, to mamy jeszcze:
-dodawanie symboli i list
-poprawki

* 01.04.2022

Dobra, skoro usuwanie symboli wydaje sie dzialac,
to teraz moze warto zajac sie dodawaniem:
- symboli w pozycji 'glowy'
- symboli w pozostalych pozycjach
- list

oraz usuwaniem list (gdy kursor jest #\[ i wcisniemy
#\delete, albo gdy jest #\] i wcisniemy #\backspace)

...

usuwanie list zaimplementowane!

* 31.03.2022

Mamy juz kasowanie jednoliterowych symboli oprocz
pozycji 0. Teraz zajmiemy sie wlasmie owa pozycja 0.

Ok, to wydaje sie zrobione.

Kolejne czynnosci do zrobienia:
- wsparcie dla list kropkowanych
- dodawanie nowych symboli na spacjach
- dodawanie list pustych na spacjach
- dodawanie symboli do list pustych
- obsluga 'strzalki w dol' (i w gore!)
- zmiana struktury dokumentu tak, zeby
  pusty dokument to bylo (()) (bo to
  najprostszy sposob zeby zapewnic mozliwosc
  dodawania nowych wyrazen
- wyswietlanie calego dokumentu (ale bez nawiasow)
- scrollowanie
- wczytywanie i zapisywanie plikow
- selekcje
- historia edycji
- cofanie operacji
- ewaluacja wyrazen
  
* 30.03.2022

Kasowanie znakow w symbolu dziala, ale efekt jest taki,
ze dostajemy puste symbole.

Stad dwie rzeczy, ktore chcemy zrobic w najblizszym
czasie:
1. jezeli wciskamy #\backspace nad symbolem ktorego
   dlugosc wynosi 1 i kursor jest na pozycji 1,
   albo #\delete nad symbolem, ktorego dlugosc
   wynosi 1 i kursor jest na pozycji 0, to
   usuwamy cala komorke z symbolem

2. jezeli wciskamy klawisz reprezentujacy znak mogacy
   byc czescia symbolu gdy kursor jest na spacji,
   to powinnismy stworzyc nowa komorke z nowym
   jednoliterowym symbolem

oczywiscie, trzeba rozwiazac pewne niuanse zwiazane z:
- pustymi listami
- listami kropkowanymi

* 29.03.2022

Pole "base" wyrugowane :D
Dalszy plan dzialania:
- klawisz #\backspace
- klawisz #\delete
- w tym: kasowanie calego symbolu (w kontekscie
zawierajacego symbol rodzica)
- tworzenie nowych symboli kiedy jestesmy
na spacji (ale to pewnie bedzie wymagalo stworzenia
Indexable Space? A moze nie? Jezeli spojrzymy na problem
z perspektywy rodzica)

* 28.03.2022

Plan na reprezentacje symboli: kazdy symbol (albo nawet
szerzej: atom) bedzie mial swoj obiekt StringBuilder.
Otrzymanie klawisza bedzie powodowalo ustawienie
aktualnego stringa jako name.

Mozna ewentualnie rozwazyc wyrugowanie pola "base"
z obiektu Symbol, co pociagneloby za soba koniecznosc
zmian w interfejsie Screen

Mozemy tak zrobic, choc to nie jest najwazniejsze.
Na razie najistotniejsze jest dodanie pelnych mozliwosci
edycyjnych do naszego edytora.

* 27.03.2022

Trzeba sie zdecydowac odnosnie tego, w jaki sposob bedziemy
reprezentowac symbole (oraz inne atomy?)

Na razie mamy taki problem, ze rzeczy, ktore RnRS uznaje
za liczby, sa u nas wyrazane zawsze jako symbole.

Zasadniczo chyba powinnismy sobie reprezentowac
atomy w taki sposob, ze:
- jezeli mamy symbol, ale zmienimy go w liczbe,
to zastepujemy go liczba
- jezeli mamy liczbe, ale zmienimy ja w symbol,
to zastepujemy go symbolem

Na razie to nie jest bardzo istotne, bo na razie
zakladamy, ze bedziemy operowac tylko na symbolach,
ale dobrze miec opcje zmiany.

* 26.03.2022

Wyobrazmy sobie na razie, ze wzbogacamy interfejs Indexable
o metode

(send-char! c::char cursor::Cursor level::int)::Cursor

i on moglby byc zaimplementowany tak:

- w klasie cons i w kombinatorach: jezeli (is level > 0)
to do (part-at (cursor level)) wysylamy wiadomosc
(send-char! c cursor (- level 1))

- w klasie Symbol: spodziewamy sie, ze level bedzie
albo 0, albo 1. Zakladajac, ze jest 1, dopisujemy
znak na pozycji (head cursor). Zwracamy kursor o glowce
zwiekszonej o 1

No, chyba ze ten klawisz to #\backspace albo #\delete.
- wtedy to trzeba 

- w klasie Space (ktora oczywiscie powstanie) robimy tak,
ze tworzymy nowy symbol, albo (jezeli klawisz to #\(
albo #\[ albo #\{) liste

No i chyba trzeba bedzie jeszcze zrobic tak, zeby nawigacja
odbywala sie za posrednictwem send-char!, ale to moze
pozniej


* 24.03.2022

Plan mamy teraz taki, zeby zajmowac sie edycja jeszcze przed
selekcja. Zadne z tych zagadnien nie jest jakies super-latwe,
ale do edycji juz co nieco mamy napisane (tzn. funkcje
take-cell-at! i put-into-cell-at!)

Na razie moze zrobmy sobie taka mala probe: jezeli kursor
wskazuje na symbol i wcisniemy "drukowalny" klawisz, to
wstawimy do tego symbola nowa litere.

Zagadnienie to zmusi nas do zastanowienia sie nad kwestia,
w jaki sposob reprezentowac symbole w naszym systemie
(i czy bedzie to wymagalo edycji reprezentacji symbolu w
Kawie)

* 22.03.2022

Poniewaz selekcja nie idzie jeszcze jakos bardzo,
to postanawiamy na razie zastanowic sie nad edycja.
Pomysl jest taki, zeby obiekt Indexable
przyjmowal zdarzenia KeyUp oraz KeyDown,
i zwracal co?

Na pewno trzeba tez bedzie zrobic tak, zeby symbole
byly mutowalne.

Dodatkowo trzeba wziac pod rozwage dodawanie do pustej
listy.

Czyli zasadniczo rzecz wyglada tak, ze chcemy miec:
1. spacje jako osobny rodzaj obiektu (ktory moze otrzymywac
wcisniecia klawiszy)
2. symbole mogace otrzymywac wcisniecia klawiszy
3. listy mogace otrzymywac wcisniecia klawiszy

Ogolniej, to by musialo dzialac tak, ze najpierw pobieramy
rodzica albo dziadka i sobie z nim gadamy, a jak oni nam
powiedza, ze mozemy gadac z lisciem, to mowimy do liscia

* 17.03.2022

Wydaje sie, ze teraz glownym problemem, z ktorym musimy
sie zmagac, jest ustalenie, czego tak naprawde chcemy.

A chcemy nastepujacych rzeczy:
1. wyrozniania selekcji podczas rysowania
2. powiekszania/zmniejszania selekcji w lewo i w prawo,
   z zachowaniem "jednorodnosci" zakotwiczenia

Jak ma dzialac to rysowanie? Wydaje sie, ze mozliwosci
sa dwie:
1. albo dla kazdego rysowanego elementu odpytujemy,
czy jego kontekst znajduje sie pomiedzy kursorem
i zakotwiczeniem, i jesli tak, to rysujemy go
w szczegolny sposob
2. albo w trakcie rysowania przelaczamy sie
pomiedzy "trybem normalnym" a "trybem selekcji"

Roznica jest taka, ze w tym ostatnim przypadku bedziemy
dodawac nowe funkcje do interfejsu Screen
(set-selection-mode!, set-normal-mode!). W tym pierwszym
przypadku mamy juz wszystko, co potrzebne.

set-selection-mode! wydaje sie o tyle spoko, ze jest
naturalnie dostosowany do biblioteki "ncurses", a i wydaje sie
przy tym, ze rowniez Android Graphics API nie powinien
robic problemow z takim sposobem uzywania (bo i tak
trzeba sie piescic z ta farba)

* 16.03.2022

Podczas renderowania musimy miec mozliwosc sprawdzania,
czy biezacy kontekst znajduje sie pomiedzy kursorem
a zakotwiczeniem; jezeli tak jest, to wlaczamy tryb
selekcji.

(a docelowo chcielibysmy chyba, zeby anchor i cursor
byly czescia obiektu Screen)


* 15.03.2022

Podsumujmy wczorajsze ustalenia:

( define ( factorial n ) ...)
           ^
           ^
(expand-selection-right '(0 1 3 1) '(0 1 3 1) #:on document)
===> (0 1 3 1) (1 1 3 1)

( define ( factorial n ) ...)
           ^^
          
(expand-selection-right '(0 1 3 1) '(1 1 3 1) #:on document)
===> (0 1 3 1) (2 1 3 1)

( define ( factorial n ) ...)
           ^ ^

(expand-selection-right '(0 1 3 1) '(2 1 3 1) #:on document)
===> (0 1 3 1) (3 1 3 1)

( define ( factorial n ) ...)
           ^  ^
...

(expand-selection-right '(0 1 3 1) '(9 1 3 1) #:on document)
===> (1 3 1) (2 3 1)

( define ( factorial n ) ...)
           ^        ^

(expand-selection-right '(1 3 1) '(2 3 1) #:on document)
===> (1 3 1) (3 3 1)

( define ( factorial n ) ...)
           \___ ___/#
	       V    V

(expand-selection-right '(1 3 1) '(2 3 1) #:on document)
===> (1 3 1) (3 3 1)

( define ( factorial n ) ...)
           \___ ___/ #
	       V     V

(expand-selection-right '(1 3 1) '(3 3 1) #:on document)
===> (1 3 1) (4 3 1)

( define ( factorial n ) ...)
           \___ ___/  #
	       V      V

(expand-selection-right '(0 3 1) '(4 3 1) #:on document)
===> ([ 3 1) (] 3 1)

( define ( factorial n ) ... )
         ^             ^

(expand-selection-right '([ 3 1) '(] 3 1) #:on document)
===> (3 1) (4 1)

( define ( factorial n ) ... )
         \______ ______/#
                V       V

Czyli mowiac w skrocie: zakotwiczony kursor rozrasta sie
tylko na tyle, na ile pozwala na to wspolny trzon kursora.

Jedyne odstepstwo od tej reguly to przypadek, gdy czubek
kursora staje sie ] - wowczas zakotwiczeniem musi byc [.

(Trzeba sie zastanowic jak to powinno dzialac od strony
interfejsu Indexable, i czy w nim nie trzeba bedzie czegos
zmieniac)


* 14.03.2022

teraz zaczynamy prace nad selekcja.
Od strony implementacji dojdzie nam 
dodatkowy parametr do funkcji
draw!, mianowicie "selection", oraz 
grupa funkcji do operowania na selekcji:
- sprawdzanie, czy dany kursor znajduje
sie pomiedzy kursorami
- powiekszanie selekcji

Od strony interfejsu, chcielibysmy
miec takie oto dodatkowe funkcjonalnosci:
- shift + strzalka (w lewo albo prawo) - powiekszanie
selekcji
- ctrl+strzalka: jezeli nie ma selekcji, to przesuwamy
kursor w lewo albo w prawo, ale na tym samym poziomie.
jezeli natomiast jest selekcja, to przesuwamy selekcje
w lewo albo w prawo na tym samym poziomie

- [ - jezeli nie ma selekcji, tworzymy nowe puste pudelko.
Jezeli jest selekcja, to tworzymy nowe pudelko w ktorym
umieszczamy owa selekcje

- ] - przesuwamy kursor pietro nizej

- ctrl+[ - jezeli mamy selekcje, to wydobywamy zaznaczone
wyrazenie przed zawierajace je pudelko. w przeciwnym razie
przesuwamy tylko kursor przed zawierajace pudelko

- ctrl+] - jezeli mamy selekcje, to wydobywamy zaznaczone
wyrazenie za zawierajace pudelko. w przeciwnym razie
tak jak ]

Natomiast alt+strzalki powinny dzialac tak, ze przesuwamy
sie po podzielonych oknach (zgodnie z "normalna" geometria),
zas ctrl+alt+strzalki pozwalaja na przenoszenie wyrazen
pomiedzy oknami

shift+alt+strzalki teoretycznie mogloby zaznaczac okna
(o ile znajdziemy sens dla takiej funkcjonalnosci)

No dobrze, fajnie, ale chyba warto by bylo sobie
wyobrazic przyklady opisujace zaznaczanie kursora

Wezmy takie cos:

#+BEGIN_SRC
       (4 1 3 1)(5 1 3 1)
      (3 1 3 1)||(6 1 3 1)
     (2 1 3 1)||||(7 1 3 1)
    (1 1 3 1)||||||(8 1 3 1)
   (0 1 3 1)||||||||(9 1 3 1)/(0-1 2 3 1)
    (0 3 1)||||||||||
   ([ 3 1) ||||||||||  (] 3 1)
         V ||||||||||  V  (0-1 3 3 1)
/        / VVVVVVVVVV  \  |           \
| define | factorial n |  |           |
|        \           ^ /  |           |
|   /    /        \  |    |         \ |
|   | if | <= n 0 |  +----+         | |
|   |    \        /                 | |
|   |                               | |
|   |       1                       | |
|   |                               | |
|   |       /     /   /       \ \ \ | |
|   |       | * n | ! | - n 1 | | | | |
\   \       \     \   \       / / / / /
#+END_SRC

Jak mamy kursor w pozycji, dajmy na to,
(1 1 3 1), i wciskamy shift+prawo,
to (1 1 3 1) staje sie naszym "zakotwiczeniem"
selekcji, natomiast kursor przesuwa sie na
(2 1 3 1). Ten sam ruch jest kontynuowany
do czasu, az dojdziemy do (9 1 3 1).

Kiedy jednak w tej pozycji ponownie wcisniemy
shift+prawo, wjezdzajac na kursor (0 2 3 1),
to nasze zakotwiczenie powinno sie zmienic
- zamiast (1 1 3 1) albo (0 1 3 1) albo
czegokolwiek, powinnismy sie zaktowiczyc
w (0 3 1) - czyli otrzymujemy selekcje
(0 3 1)-(2 3 1). W taki wlasnie sposob
powinnismy moc od tej pory powiekszac
nasza selekcje: nie o pojedyncze znaki, a
o cale wyrazenia.

Co wiecej, jezeli przekroczymy kursor (4 3 1)
i wjedziemy na (] 3 1), to od zakotwiczenie
powinno awansowac na ([ 3 1).


* 13.03.2022

kursor juz jako tako obsluzony, teraz jeszcze
pozostaje nam:
1. selekcja
2. edycja
3. scrollowanie dokumentu
4. otwieranie i zapisywanie plikow

i juz bedziemy miec uzyteczny edytor
strukturalny

dalsze kroki:
5. ewaluacja lispa
6. mechanizm rozszerzen

7. klient graficzny
8. klient androidowy
9. system gestow




* 12.03.2022

najwazniejsze rzeczy do zrobienia:
- umieszczanie kursora na poszczegolnych
  literkach/spacjach
- zaznaczanie wyrazen i podswietlanie
  zaznaczenia

Jak rozwiazac umieszczanie kursora?

* 11.03.2022

wydaje sie, ze powinnismy moc zrezygnowac
z predykatu has-children?
hmmm to sie chyba nie uda?
raczej uda.

jezeli first-index i last-index zwracalyby
#!null, to to powinno rozwiazac problem.

chcemy zatem miec:
- spacje jako Indexable
- indeksowanie po symbolach

Wydaje sie, ze bedzie trzeba rozpoczac od spacji:
- obsluga w parserze
- obsluga w wyswietlaniu
- obsluga podczas iterowania

Uwaga! Implementacja take-cell-at! w naturalny
sposob operuje na nieparzystych indeksach
(ktore wskazuja na elementy), natomiast
put-into-cell-at! w naturalny sposob operuje
na parzystych indeksach (ktore wskazuja na
spacje)


* 10.03.2022

trzeba troche popracowac koncepcyjnie nad
fundamentami. ba razie rzecz wyglada tak, ze
mamy interfejs Indexable o takiej postaci:
(indexable.scm)

(define-interface Indexable ()
  (has-children?)::boolean
  
  (part-at index::Index)::Indexable*
  
  (first-index)::Index
  (last-index)::Index
  
  (next-index index::Index)::Index
  (previous-index index::Index)::Index
)

oraz jego dwie implementacje (primitive.scm): cons 
i Symbol.

Metoda has-children? jest uzywana przez
cursor-climb-front oraz cursor-climb-back,
podobnie jak first-index i last-index,
odpowiednio.

part-at jest dodatkowo uzywana w cursor-ref;
next-index w cursor-next, a previous-index
w cursor-back

no dobrze, ale wyglada na to, ze chcemy
obslugiwac kilka odrebnych czynnosci:
- poruszanie kursora (poprzedni/nastepny)
- wyodrebnianie elementu pod kursorem


* 09.03.2022

jeszcze chyba jakies bledy sa w tym zaznaczaniu.
no ale niewazne.

* 08.03.2022

wydaje sie, ze odwzorowywanie klikniec w wyrazenia
jako tako dziala, choc konieczne bedzie jeszcze
przetestowanie na pc.

tymczasem chcielibysmy sie skupic na kolejnym
aspekcie, mianowicie na - z jednej strony
- iterowaniu na pod-indeksach spacji i atomow,
oraz - z drugiej strony - zmianie reprezentacji
spacji

reprezentacja spacji powinna byc taka, ze mamy
sobie liste.
i w tej liscie bedziemy mieli albo liczbe,
albo "pudelko":
liczba oznacza ilosc spacji (poziomych), przerwa
miedzy liczbami - spacje pionowa, natomiast
"pudelko" to wykomentowane wyrazene
(przez "pudelko" rozumiem tutaj pare, ktorej ogon
to lista pusta, albo inaczej - liste jednoelementowa)

* 28.02.2022

Dzis tak moze nieco skromniej: mamy napisany zarys funkcji
"cursor-under". Teraz istotne jest, zeby te funkcje podlaczyc
do kodu obslugujacego klikniecia mysza.

A w dalszej kolejnosci bedziemy chcieli:
- iterowac po spacjach i symbolach (zmienic reprezentacje spacji)
- wydobywac wyrazenia za pomoca klikniec
- zaznaczac wyrazenia
- edytowac z klawiatury

* 25.02.2022

Byloby dobrze przemyslec interfejsy, zeby nie musiec po
wielokroc dokonywac refaktoryzacji (choc wyglada na to,
ze ta ostatnia nie poszla najgorzej)

Bo chcemy miec mozliwosc poruszania sie strzalkami
lewo/prawo po symbolach, ale takze po stringach, komentarzach,
pudelkach...

Po stringach cheilibysmy moc sie poruszac "gora/dol",
i to w taki sposob, ze gora to jest poprzednia linia,
zas dol to kolejna linia.

Wydaje sie, ze wszystkie komponenty musza moc otrzymywac
polecenia:

(define-interface Editable ()
  (type c::char)::bool
  )

(define-interface Navigable ()
  (up)::Index
  (down)::Index
  (left)::Index
  (right)::Index
  )

* 23.02.2022

** rano:

Kolejne rzeczy, ktore chcielibysmy zrobic:
- iterowanie po kazdej literce symbolu, i po kazdej spacji
  (przy okazji - zmiana reprezentacji spacji (1) w parserze,
   (2) w funkcji show i (3) w funkcji draw!)
- mapowanie polozenia myszy we wspolrzedne dokumentu
- edycja dokumentu, czyli:
  - dodawanie nowych symboli
  - edycja symboli
  - kasowanie symboli i list
  - zaznaczanie wyrazen
  - tworzenie nowych list
- poruszanie sie w gore i w dol
- obsluga komentarzy
  - liniowych (jako panel obok oryginalnego wyrazenia)
  - blokowych (jako "karteczka" z tekstem)
  - wyrazeniowych (jako wyszarzone wyrazenia)

No dopsz. To teraz rozwazmy to, w jaki sposob musi
dzialac obsluga myszy. Na razie myslimy o takich
scenariuszach
- klikniecie i puszczenie myszy powoduje selekcje
kursora w danym miejscu
- klikniecie na lewy nawias powoduje wyodrebnienie
pudelka (drag&drop)
- klikniecie na prawy nawias powoduje zmiane rozmiaru
itd.

** Z OSTATNIEJ CHWILI!

Zmieniamy interfejs Tile tak, zeby metoda draw!
nie zwracala Extenta. Zamiast tego bedziemy mieli osobne
metody width i height, ktore w dodatku bedziemy
cache'owac dla poszczegolnych par, i inwalidowac
cache po kazdej iteracji

W kazdym razie plan refaktoryzacji jest taki,
ze musimy stworzyc funkcje wyliczajae rozmiary
poszczegolnych wyrazen (tzn. wysokosc i szerokosc),
bo one beda potrzebne przy rysowaniu.

Musimy tez zaktualizowac wszystkie kombinatory zeby
obslugiwaly nowy interfejs.

* 22.02.2022

Wyglada na to, ze trzeba na powaznie przemyslec kwestie
iterowania po kursorze w trakcie renderowania.

Na razie udalo sie zrobic cos co jako tako dziala dla list,
ale nie do konca sie wpisuje we framework "rzeczy indeksowalnych".

Kuszace wydaje sie to, zeby juz podczas renderowania umieszczac
kursor w odpowiednim miejscu w obiekcie Screen.

Do tego dochodzi jeszcze kwestia poruszania sie po symbolach
i spacjach, ktora tez trzeba bedzie rozwiazac, podobnie jak
kwestie integracji z kursorem myszy itp.

Ewentualnie te ostatnia mozna rozwiazac w taki sposob, ze obiekt
Screen bedzie przechowywal wspolrzedna dotyku, i podczas
"normalnego" rysowania bedziemy sprawdzac, czy akurat znajdujemy sie
gdzies w jego zakresie.

Hmm... wyglada nawet obiecujaco.

* 20-21.02.2022

mamy zaimplementowane operacje:

take-cell-at!
put-into-cell-at!

pewnie beda wymagaly jeszcze dopracowania
(np. obsluga list elementow, zamiast pojedynczych elementow),
ale moze bedzie mozna ich uzyc do implementacji operacji
na dokumencie.

Ogolnie, nasz dokument jest reprezentowany przez "pudelko".
czyli komorke, ktorej "car" jest wlasciwym dokumentem
(ktory moze byc lista pusta, jezeli dokument jest pusty),
a ktorej "cdr" nie ma znaczenia (ale zasada najmniejszego 
zaskoczenia nakazuje nam oczekiwac, ze to bedzie '())
 
Teraz chcielibysmy zrobic tak, zeby operacje, ktore sobie
zdefiniowalismy w document-operations byly realizowane
za posrednictwem naszych implementacyj.

Ale do tego pozostaje jeszcze kwestia, w jaki sposob
pogodzic ze soba te operacje oraz interfejs edytora.

Wydaje sie, ze tutaj problem jest taki, ze nie wiemy,
w ktorym miejscu na ekranie powinien sie znajdowac kursor.

Stad moja "chamska" propozycja jest taka, zeby podczas
renderowania sprawdzac, czy kursor danego elementu jest
identyczny z aktualnym kursorem, i jezeli tak, to
zapisywac aktualna pozycje rysowania w jakiejs zmiennej.

(pozniej to oczywiscie zmienimy, hehe)

* 16.02.2022

strategua dzialania jest teraz taka:
1. projektujemy warstwe interfejsow na dokumencie
2. tworzymy generowana z lispowych par strukture posrednia
3. implementujemy renderowanie, nawigacje itd. albo za pomoca
struktury posredniej, albo - jezeli cos sie okaze nie tak
- za pomoca dotychczasowego podejscia

* 15.02.2022

integracja map kursorowych z funkcja renderujaca wydaje sie
na razie raczej trudna. stad rodzi sie nam Zupelnie Nowy Pomysl,
zeby s-wyrazenia konwertowac do struktury posredniej, ktora
z jednej strony bedzie mozna wyrenderowac na ekran, a z drugiej
nawigowac za pomoca kursora

Bedziemy zatem oprocz klasy Screen miec klase Sheet (albo Projection?),
ktora bedzie mniej wiecej odpowiadac temu, co wymyslilismy w javowym
prototypie albo w implementacji LinearCursorMap.

No dobrze, to sie wydaje calkiem fajny pomysl. Ale jest jeszcze
kilka "ale".


(define-interface DocumentOperations ()
  (add expression::SExpression cursor::Cursor)::void
  (remove expression::SExpression cursor::Cursor)::void
  (move source::Cursor target::Cursor))

(define-interace PlanarProjection ()
  (draw! screen::Screen)::void
  (area-under left::real top::real)::Area)

Tutaj mamy jakies czarodziejstwa z TODO-listy ze 'stages':

(define-type document-operation
  (extend in-document-context
    (either
      (move-expression :from source::track :to destination::track)
      (copy-expression :from source::track :to destination::track)
      (replace expression :at track::track :with another-expression)
      (remove expression :at track::track)
      (insert expression :at track::track)
      (splice-box :spanning [x::real y::real w::real h::real]
                  :at track::track)
      (create-box :spanning [x::real y::real w::real h::real]
                  :at track::track)
      (improperize-box :at track::track)
      (properize-box :at track::track)
) ) )

(declare reciprocal : document-operation -> document-operation)

(define (reciprocal operation)
  (parameterize ((current-document (:in operation)))
    (match operation
      [(move-expression :from source :to destination)
       (move-expression :from destination :to source)]
      [(copy-expression :from source :to destination)
       ...]
      [(replace expression :at track :with another-expression)
       (replace another-expression :at track :with expression)]
      [(remove expression :at track)
       (insert expression :at (previous-track track))]
      [(insert expression :at track)
       (remove expression :at (subsequent-track track))]
      [(splice-box :spanning [x y w h] :at track)
       (create-box :spanning [x y w h] ...?)]
      [(create-box :spanning [x y w h] :at track)
       (splice-box :spanning [x y w h] ...?)]
      [(improperize-box :at track)
       (properize-box :at track)]
      [(properize-box :at track)
       (improperize-box :at track)]
) ) )


* 14.02.2022
  
pomysl: interpreter lispa, w ktorym funkcje ze skutkami ubocznymi
ewaluuja sie gorliwie, a te bez skutkow ubocznych - leniwie.

* 11.02.2022


No dobra, trzeba sobie teraz jeszcze troche popisac, powymyslac.
Otoz po pierwsze, Sekcje rekurencyjnie beda w sobie zawierac
mapy kursorow. Po drugie, troche trzeba przemyslec strategie
recyklingu.

Na poczatek jednak olejmy sobie kwestie recyklingu kompletnie,
a martwmy sie nia dopiero pod koniec.

Na razie skupmy sie na wypelnianiu tablicy elementami.
I otoz zasadniczo zmiay beda potrzebne w funkcji draw!
z modulu "primitive".

OK, super, i teraz jak to ma dzialac:  za kazdym razem, kiedy
narysujemy jakis obiekt i znamy jego rozmiar, dodajemy do nasze
mapy sekcje. Natomiast w przypadku kiedy zaczynamy rysowac spacje,
to dodajemy nową sekcję, i jeżeli otrzymamy znak nowej linii,
dodajemy nową linię.

W przypadku gdy rysujemy sekwencję, to każde wywolanie
draw! albo draw-empty-list! powinno moc potencjalnie
dodac nowa mape kursora do biezacej sekcji, ale trzeba
sobie dobrze przemyslec, w jaki sposob sie to powinno
odbywac.

Na pewno do kazdej funkcji rysujacej


* 08.02.2022

Dodanie opcji recyklingu do konstruowania obiektow, parametryzowanego
typem. Mozemy sobie pisac

(Recycled Line next: null height: real)

i mamy wowczas mozliwosc otrzymania obiektu z odzysku (po wywolaniu
(recycle Line)).

No i pieknie. I teraz podczas rysowania bedziemy sobie tworzyc
strukture, moze

ArrayList<Line> lines;


  
  
* 07.02.2022
trzeba wreszcie zaimplementowac te klikania, przy czym mamy
do wyboru dwie strategie implementacyjne:
1. parametryzacja funkcji "draw!" w taki sposob, zeby otrzymywala
opcjonalnie predykat decydujacy o tym, ze sie ma zakonczyc, 
2. generowanie struktury pomocniczej

Ogolnie jestem bardziej przychylny opcji 2, poniewaz wydaje sie
prostsza implementacyjnie i wydajniejsza. (A przy tym problemem
w opcji 1 jest to, ze nie znamy wysokosci linii do czasu, az
nie dojdziemy do ostatniego elementu)

Trzeba przy tym jednak pamietac, ze ta sama komorka ("cons-cell")
moze byc wyswietlona kilkukrotnie, w zwiazku z tym raczej nie 
powinna byc kluczem dla niczego zwiazanego z wyswietlaniem.

Natomiast tym, co w naszym renderowaniu niewatpliwie jest unikatowe
(choc na swoj sposob efemetyczne) sa kursory, ktore "wewnetrznie"
sa alokowane za pomoca "hash-consingu" - acz jezeli zostanie
uzyta w charakterze mocnej referencji, to jej efemeryczny charakter
nie powinien byc problemem.

Czyli na razie sobie wyobrazam, ze rysowanie na obiekt Screen
bedzie jednoczesnie utrzymywac pomocnicza strukture postaci:

Linia (Jej Wysokosc): Przedzial (Jego Szerokosc, Kursor, Linia?) ...

(define-type (Line next: Line 
                   height: real))

(define-type (Section width: real 
                      cursor: Cursor 
                      inner: Line))

I teraz tak: w momencie, gdy dokument zrodlowy sie zmieni,
struktura pomocnicza przestanie byc aktualna i trzeba ja bedzie
wygenerowac od nowa. Pytanie: czy mozliwe jest, zeby w jakis
sposob minimalizowac ilosc generowanego smiecia?

I co wiecej, w jaki sposob mozemy zapewnic, ze powtorne
wyrenderowanie takiej samej struktury nie spowoduje nowej alokacji?

No coz. Moglibysmy zrobic tak, ze zaalokowane elementy bedziemy
sobie cache'owac w tablicy. Przy czym ta tablica moze byc albo
slabym haszem indeksowanym kursorami (czyli np. property+),
albo sekwencja indeksowana kolejnymi liczbami naturalnymi.


* 06.02.2022

interfejs do budowania struktury pomocniczej 
przypisujacej wspolrzednym ekranowym kursory
z oryginalnego wyrazenia:

- dodaj element (szerokosc, wspolrzedna kursora)
- zakoncz biezaca linie (wysokosc)

Zalozenia implementacyjne:
- kolejne przerysowywanie takiego samego dokumentu
nie powinno powodowac dodatkowych alokacji

- lokalne zmmiany nie powinny inwalidowac zbyt wielu
elementow (a w kazdym razie powinny maksymalizowac
uzywanie zaalokowanych zasobow)

(define-interface CursorMap ()
  (finish-line!)::void
  (add-entry! width::real cursor::Cursor)::void

  (cursor-at left::real top::real)::Cursor
  (position cursor::Cursor)::Point)


* 05.02.2022

(cursor-ref document::Indexable cursor::Cursor) -> element
(screen:cursor-at left::real top::real) -> Cursor
(screen:position cursor::Cursor) -> Point
(screen:extent cursor::Cursor) -> Extent

Teraz pomysł jest taki, żeby wynikiem renderowania byla
struktura podobna do tej ze starego prototypu, tzn.
lista linii zawierajaca liste elementow, gdzie kazdy
z elementow albo jest finalnym elementem, albo
kontenerem zawierajacym liste

* 04.02.2022

wczoraj i przedwczoraj zajmowalem sie glownie analizatorem
zaleznosci i refaktoryzacja modulow, majaca na celu znalezienie
odpowiedniego miejsca do przechowywania spacji.

Nowy typ "spacji" zostal juz co prawda zdefiniowany, ale jeszcze
nie jest uzywany, i wymaga sporo dopracowania.

Czyli plan wyglada na razie tak: wyodrebniamy typ spacji,
okreslamy reguly indeksowania i zastepujemy aktualna reprezentacje
spacji w parserze, funkcji wyswietlajacej oraz funkcji rysujacej

Nastepnie chcielibysmy stworzyc odwzorowania dla elementow
przestrzennych w ich polozenie i rozmiary

* 02.02.2022 

wczoraj narodzil sie taki pomysl, zeby utrzymywac mape
z polozeniami tylko dla nieparzystych indeksow

ogolnie wydaje sie tez, ze niezbedne bedzie wydzielenie
spacji jako osobnego typu, przy czym moze byc tak, ze
bedziemy owe spacje reprezentowac po prostu jako listy
liczb calkowitych, gdzie liczba oznacza spacje, zas
przejscie do nastepnego elementu oznacza nowa linie.


* 01.02.2022 
podczas rysowania chcemy tworzyc pomocnicza
strukture, ktora po pierwsze bedzie nam odwzorowywac
obszary ekranu w kursory widgetow, a po drugie bedzie
umozliwiac odwzorowywanie kursorow w polozenia widgetow


Wezmy takie cos:

#+BEGIN_SRC
/        /             \              \
| define | factorial n |              |
|        \             /              |
|   /    /        \                 \ |
|   | if | <= n 0 |                 | |
|   |    \        /                 | |
|   |                               | |
|   |       1                       | |
|   |                               | |
|   |       /     /   /       \ \ \ | |
|   |       | * n | ! | - n 1 | | | | |
\   \       \     \   \       / / / / /
#+END_SRC


odpowiadajaca temu struktura moglaby wygladac z grubsza
tak:

#+BEGIN_SRC
 _____________________________________
# |    | # |       | # #              #
# |    | # |       | # #              #
#_|____|_#_|_______|_#_#______________#
#   # || # || # # #                 # #
#   # || # || # # #                 # #
#   #_||_#_||_#_#_#_________________#_#
#   #       #                       # #
#   #       #                       # #
#   #_______#_______________________#_#
#   #       # # # # # # # # # # # # # #
#   #       # # # # # # # # # # # # # #
#___#_______#_#_#_#_#_#_#_#_#_#_#_#_#_#
#+END_SRC

albo, jesli ja dwukrotnie powiekszymy:

#+BEGIN_SRC
  __________________________________________________________________________
||   |        |   ||   |              |   ||  ||                            ||
||   |        |   ||   |              |   ||  ||                            ||
||   |        |   ||   |              |   ||  ||                            ||
||   |        |   ||   |              |   ||  ||                            ||
||   |        |   ||   |              |   ||  ||                            ||
||___|________|___||___|______________|___||__||____________________________||
||      ||  |  |  ||  |  |  ||  ||  ||                                  ||  ||
||      ||  |  |  ||  |  |  ||  ||  ||                                  ||  ||
||      ||  |  |  ||  |  |  ||  ||  ||                                  ||  ||
||      ||  |  |  ||  |  |  ||  ||  ||                                  ||  ||
||      ||  |  |  ||  |  |  ||  ||  ||                                  ||  ||
||      ||__|__|__||__|__|__||__||__||__________________________________||__||
||      ||              ||                                              ||  ||
||      ||              ||                                              ||  ||
||      ||              ||                                              ||  ||
||      ||              ||                                              ||  ||
||      ||              ||                                              ||  ||
||      ||______________||______________________________________________||__||
||      ||              ||  ||  ||  ||  ||  ||  ||  ||  ||  ||  ||  ||  ||  ||
||      ||              ||  ||  ||  ||  ||  ||  ||  ||  ||  ||  ||  ||  ||  ||
||      ||              ||  ||  ||  ||  ||  ||  ||  ||  ||  ||  ||  ||  ||  ||
||      ||              ||  ||  ||  ||  ||  ||  ||  ||  ||  ||  ||  ||  ||  ||
||      ||              ||  ||  ||  ||  ||  ||  ||  ||  ||  ||  ||  ||  ||  ||
||______||______________||__||__||__||__||__||__||__||__||__||__||__||__||__||
#+END_SRC

A jesli dodatkowo uzupelnimy wspolrzednymi kursorow, to dostaniemy takie cos:

#+BEGIN_SRC
0
  __________________________________________________________________________
(|0  |1 define|2  (|0  |1 factorial   |2  3n4 )|*                           ||
1|1  |1       |1  3|3  |3             |3  3|3 3|4                           ||
||   |        |   1|1  |1             |1  1|1 1|1                           ||
||   |        |   ||   |              |   ||  ||                            ||
||   |        |   ||   |              |   ||  ||                            ||
||___|________|___||___|______________|___||__||____________________________||
||*     (|0 |1 |2 (|0 |1 |2 3|4 5|6 )|*                                 ||  ||
||4     5|5 |5 |5 3|3 |3 |3 3|3 3|3 3|4                                 ||  ||
||1     1|1 |1 |1 5|5 |5 |5 5|5 5|5 5|5                                 ||  ||
||      ||  |if|  1|1 |1 |1 1|1 1|1 1|1                                 ||  ||
||      ||  |  |  ||  |<=|  n|  ||  ||                                  ||  ||
||      ||__|__|__||__|__|__||__||__||__________________________________||__||
||      ||*             5|*                                             ||  ||
||      ||4             5|6                                             ||  ||
||      ||5             1|5                                             ||  ||
||      ||1             ||1                                             ||  ||
||      ||              1|                                              ||  ||
||      ||______________||______________________________________________||__||
||      ||*             (|0 1|2 3|4 (|0 1!2 (|0 1-2 3n4 516 )|4 )|6 )|8 )|6 )|
||      ||6             7|7 7|7 7|7 5|5 5|5 3|3 3|3 3|3 3|3 3|5 5|7 7|5 5|1 1|
||      ||5             5|5 5|5 5|5 7|7 7|7 5|5 5|5 5|5 5|5 5|7 7|5 5|1 1|  ||
||      ||1             1|1 1|1 1|1 5|5 5|5 7|7 7|7 7|7 7|7 7|5 5|1 1|  ||  ||
||      ||              ||  *|  n|  1|1 1|1 5|5 5|5 5|5 5|5 5|1 1|  ||  ||  ||
||______||______________||__||__||__||__||__1|1_1|1_1|1_1|1_1|__||__||__||__||

2
#+END_SRC

(1) (1 1)define (3 1) (1 3 1)factorial (3 3 1)n (5 1) (1 5 1)if (3 5 1)
(1 3 5 1)<= (3 3 5 1)n (5 3 5 1)1 (7 5 1) (1 7 5 1)* (3 7 5 1)n

No i super. I teraz chcielibysmy to sobie reprezentowac za pomoca jakiejs
struktury danych.

Wyobrażam sobie coś takiego:

(define-alias Cursor/Line java.lang.Object)

(define-type (Line height: real
                   contents: Span
                   next: Line))

(define-type (Span width: real
                   target: Cursor/Line
                   next: Span))

No i dopsz. I teraz mamy dwie misje: po pierwsze, chcemy odwzorowac
wspolrzedne ekranowe w kursor, a po drugie chcemy odwzorować kursor
w obszar na ekranie.

Wezmy sobie definicje:
#+BEGIN_SRC
(define (factorial n)
	 (if (= n 0)
	     1
	     (* n (factorial (- n 1)))))
#+END_SRC
Sklada sie z 20 komorek ("cons") oraz 21 "lisci", w sumie
41 elementow. Nie uwzgledniajac pozycji na bialych znakach
ani na symbolach, mozemy naliczyc 55 kursorow odnoszacych
sie do tego wyrazenia.

To chyba nie jest jakas szczegolna eksplozja kombinatoryczna;
raczej przyrost liniowy.

Atrakcyjnym aspektem kursora wydaje sie to, ze jest w nim
ujeta hierarchia zawierania: ze relacja (potomek | przodkowie)
zawsze ujmuje potomka wzgledem przodkow.

Jednakze nie mozemy niestety zakladac, ze hierarchi "rodzicielstwa"
odpowiadaja zawierajace sie prostokaty, poniewaz tak z cala pewnoscia
nie jest w przypadku bialych znakow zawierajacych znak nowej
linii.

Zakladajac, ze mamy do dyspozycji strukutre taka jak ta narysowana
powyzej, mozemy sobie w liniowy sposob wyszukac pozycje danego
kursora.

Ale 


* 31.01.2022

mamy juz nawigowanie strzalkami w lewo i prawo.

i to jako tako dziala. co chcemy teraz?
- chcemy, zeby edytor wyswietlal wyrazenia za pomoca naszej
  funkcji renderujacej
- i zeby mozna sie bylo poruszac strzalkami po tych wyrazeniach
- i zeby mozna bylo uzywac klikniecia myszy do umiejscowienia
  kursora w odpowiednim miejscu

a w dalszej kolejnosci:

- zaznaczanie wyrazen
- drag&drop (lewy nawias) oraz zmiany rozmiaru (prawy nawias)
- poruszanie sie strzalkami po liniach

No dobra. To co sie musi tak naprawde dziac?

* starsze

Duzo decyzji projektowych przed nami!

oto ficzery, ktore miec chcemy:
- nawigowanie strzalkami kursora po wyrazeniach
- zaznaczanie wyrazen (shift + szczalka)
- wiele paneli (podzial pionowy i poziomy)
- wycinanie (ctrl+x), kopiowanie (ctrl+c) i wklejanie (ctrl+v)
- sledzenie historii, 'undo' (ctrl+z)

No dopsz. To teraz jak to reprezentowac?


#+BEGIN_SRC
(define-interface Panel ()
  ...)

(define-type (Split first: Panel
                    second: Panel
		    first%: real)
  implementing Panel
  with
  ...)

(define-type (Editor document: Document
                     cursor: Cursor
		     selection-start: Cursor
		     screen: Screen)
  implementing Panel
  with
  ...)

#+END_SRC

