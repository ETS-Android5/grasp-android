

16.05.2021 kolejny krok: trzeba okreslic warunki, w ktorych
wymyślone poprzednio rodzaje zdarzeń będą generowane.

zacznijmy od określenia warunków, w jakich są generowane
zdarzenia:
- tap
- double tap
- hold

w przypadku double tap, mamy najpierw zdarzenia down, move* i up.
po wciśnięciu, ale przed wygenerowaniem kolejnego zdarzenia
'down', jest wygenerowane zdarzenie '2tap'. co więcej,
jeżeli palec nie zostanie puszczony, to dodatkowo zostanie
wygenerowane zdarzenue 'hold'.

zdarzenie doubleClick chcemy generować, gdy zarejestrowaliśmy
zdarzenie 'doubleTap', a w krótkim czasie po nim - zdarzenie 'up',
zaś w międzyczasie nie było zdarzenia 'move' w dużej odległości

zdarzenie secondPress chcemy generować, gdy zarejestrowaliśmy
zdarzenie 'doubleTap', a po nim (przed zarejestrowaniem
zdarzenia 'up') zdarzenie 'move' na dużą odległość

zdarzenie onHold chcemy generować, gdy dostaliśmy zdarzenie
onLongPress i ostatnie zdarzenie wciśnięcia nie było
poprzedzone zdarzeniem doubleTap

zdarzenie onClick to po prostu onTap, ale trzeba zapewnić,
że wywołanie Down a po nim Up jest neutralbe dla historii
i struktury dokumentu


15.05.2021 zasadniczo itemAt jest juz zaimplementowane,
natomiast z takeFrom jest pewien problem z przetestowaniem,
ponieważ trzeba by to było jakoś podpiąć do interfejsu.

i tutaj jest problem, bo trzeba w jakiś sposób propagować
zdarzenia przez warstwy 'splitów'. w związku z czym musimy
sobie zdefiniować, jakie zdarzenia w ogóle chcielibyśmy
obsługiwać.

Drag onPress()
void onClick()
Drag onSecondPress()
void onDoubleClick()
Drag onHold()

13.05.2021 kolejnosc dzialan:

najpierw chcielibysmy zaimplementowac funkcje, ktora dla
okreslonej wspolrzednej zwraca nam Bit znajdujacy sie
pod ta wspolrzedna, przy czym:
- dla nawiasow, interlinii i spacji zwraca odpowiednie pudelko
- dla atomow zwraca atom

Bit itemAt(float x, float y)

dodatkowo chcielibysmy miec metode

bool insertAt(float x, float y, Bit item)


ktora umieszcza dany element na okreslonej pozycji
(albo zwraca false, jesli sie to nie uda, np. gdy x i y
to posycja Atomu)

oraz

Bit takeFrom(float x, float y)

ktore wyciagaja element spod wspolrzednej (x, y)


12.05.2021 trzeba rozkminic interakcje:

- chwytanie za nawiasy i atomy powinno powodowac wyciaganie
odpowiedniego wyrazenia (a upuszczenie - umieszczenie wyrazenia
w jakims miejscu)

- rozciąganie przeciagniętego wyrażenia powoduje
zmianę rozmiaru (na ile to możliwe)

- podwojne klikniecie i rozpoczecie przeciagania (nawias
lub atom) powinno spowodowac skopiowanie danego wyrazenia

- szybkie wyrzucenie przeciaganego wyrazenia powinno spowodowac
jego usuniecie

- pojedyncze klikniecie na spacje albo interlinie powinno
spowodowac umieszczenie w danym miejscu kursora. klikniecie
na nawias albo atom powoduje jego zaznaczenie. klikniecie
na zaznaczony atom umieszcza kursor miedzy literami

- podwojne klikniecie nawiasu powinno spowodowac jego
pokazanie/ukrycie

- podwojne klikniecie wyrazenia powinno powodowac jego
'reindentacje'

- przytrzymane nad wyrazeniem powoduje wyswietlenie
pop-upu z lista dostepnych akcji. na dokumencie bedzie
to otwarcie, zapis, przelaczenie itd.
na pustym pudelku bedzie to konwersja do specjalnego
typu pudelka, i tak dalej (nie wiemy jakie sa wszystkie
mozliwosci, ale chcemy raczej stworzyc mechanizm)

dla wyrazen lispowych opcja powinna byc ekspansja (dla makr),
redukcja albo ewaluacja

dla argumentow funkcji opcja powinna byc zmiana nazwy

dla rogów nawiasów możliwe jest przypięcie pinezki

dla "pustego atomu" opcje dodania nowego albo wyboru
istniejacego (z popularnych albo wedlug modulow/tagow)




9.05.2021 plan dzialania:
- trzeba wypracowac jakąś reprezentację dla dokumentów,
żeby mogły miec więcej niż jedno wyrażenie z przeparsowanego
stringa.
- nastepnie trzeba zrobic tak, zeby zdarzenia dotyku
byly propagowane do najbardziej odpowiedniego widgetu
podrzednego
- i trzeba troche dojsc do porzadku z tymi interliniami
i tym, co jak jest wyswietlane

7.05.2021

kolejne kroki:
- wcisniecie lewego nawiasu powinno powodowac wydobycie
danego boxu z jego rodzica
- podwojne wcisniecie lewego nawiasu powinno spowodowac
stworzenie kopii
- wcisniecie prawego nawiasu powinno powodowac zmiane
rozmiaru
- wcisniecie (tapniecie) atomu, interlinii albo pustej
przestrzeni powinno spowodowac umieszczenie w danym
miejscu kursora tekstowego
- nawigacja za pomoca strzalek
- 

25.04.2021

Spinanie parsera z edytorem:
- dotykanie dwoma palcami powinno powodowac scrollowanie
danego edytora (i ewentualnie jego zoomowanie)
- kazdy edytor powinien domyslnie otwierac dokument
ze StringReadera


(a kiedy to juz bedzie gotowe, bedzie mozna pobawic sie
w edycje dokumentow oraz otwieranie i zapisywanie plikow)


22.04.2021

Mamy juz:
- parsowanie
- konwersje s-wyrazen do bitow (na razie bez list kropkowanych)

Co teraz chcemy miec:
- rysowanie bitow i spiecie tego z GRASP
- ale przy okazji tez scrollowanie i zoomowanie ekranu
- oraz oczywiscie mozliwosc edycji dokumentow (na razie tyle
ze chcemy moc wyciagac elementy z innych elementow
i wkladac je w elementy, ale docelowo rowniez kopiowac
elementy, tworzyc nowe elementy, kasowac elementy ...)
- oraz wczytywania i zapisywania

- jest jeszcze taka kwestia, ze mialoby sens robienie listy
dwukierunkowej elementow, dzieki czemu podczas scrollowania
nie trzeba by bylo kazdorazowo przegladac listy od poczatku,
a tylko jej lokalne otoczenie


zaleznosci:
- wczytywanie i zapisywanie wymaga wyswietlania listy plikow
i nawigacji po katalogach, ktore z kolei sa blokowane przez
architekture widgetow

- wydaje sie, ze na razie mozemy zrobic wyswietlanie
jakiegos wybranego dokumentu

teraz jak to wplesc w architekture?

Mamy sobie funkcje Editor::render oraz pole Editor::document.

Document mogloby miec typ 'Box'. Wowczas Editor::render
robiloby tyle, ze by odpowiednio ustawialo macierz i przyciecie
plotna i przekazywalo odpowiednie parametry do Box::render,
ktore renderowaloby swoje elementy rekurencyjnie.

Box::render powinien wywolac Interline::render, ktora przesunie
odpowidnio macierz i zrobi Line::render, ktora wywola...
fajnie by to bylo robic rekurencyjnie, ale niestety JVM nie
ma TCO. Zatem trzeba przeiterowac w petli for, w ktorej bedziemy
kazdorazowo zdejmowac macierz ze stosu j kumulowac
przesuniecie


najpierw jednak zaczniemy od przeniesienia wszystkiego do
katalogu stage3, zeby moc dalej nad tym pracowac


cons: A [A] -> [A]

class Construction a 
   cons: A B -> B
  bg: B -> AG